import{_ as e,c as t,o,ae as r}from"./chunks/framework.DqA2quMh.js";const _=JSON.parse('{"title":"中间代码表示","description":"","frontmatter":{},"headers":[],"relativePath":"bytecode/index.md","filePath":"bytecode/index.md"}'),l={name:"bytecode/index.md"};function i(n,a,d,h,c,p){return o(),t("div",null,[...a[0]||(a[0]=[r('<h1 id="中间代码表示" tabindex="-1">中间代码表示 <a class="header-anchor" href="#中间代码表示" aria-label="Permalink to &quot;中间代码表示&quot;">​</a></h1><p>在 OpenEX 中, 整个解释器分为两部分:</p><ul><li>前端编译器</li><li>执行引擎</li></ul><p>在两部分中间传输的数据叫做中间代码 (也叫字节码)</p><h2 id="索引" tabindex="-1">索引 <a class="header-anchor" href="#索引" aria-label="Permalink to &quot;索引&quot;">​</a></h2><p>索引了字节码总体类型, 方便查找</p><ul><li><a href="./vm_table_opt.html">操作类型指令</a></li><li><a href="./vm_operation.html">运算类型指令</a></li></ul><h2 id="源文件输出格式" tabindex="-1">源文件输出格式 <a class="header-anchor" href="#源文件输出格式" aria-label="Permalink to &quot;源文件输出格式&quot;">​</a></h2><p>OpenEX 前端编译器在转换成执行引擎可以识别的字节码集合结构中包含以下几个部分</p><h3 id="常量表" tabindex="-1">常量表 <a class="header-anchor" href="#常量表" aria-label="Permalink to &quot;常量表&quot;">​</a></h3><p>存储脚本源码中定义的一些字面量, 为减小指令宽度, 方便管理而出现的数据结构.</p><h3 id="方法表" tabindex="-1">方法表 <a class="header-anchor" href="#方法表" aria-label="Permalink to &quot;方法表&quot;">​</a></h3><p>存储了源文件中定义的所有函数, 包括函数需要的形参个数, 函数名, 局部变量表大小等信息.</p><blockquote><p>在字节码集合结构导出中, 脚本根作用域的字节码会被转换成一个 <code>root</code> 方法,<br> 该方法对其他脚本访问透明, 只有执行引擎可主动调用.</p></blockquote>',14)])])}const u=e(l,[["render",i]]);export{_ as __pageData,u as default};
