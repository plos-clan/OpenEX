import{_ as e,c as s,o as i,ae as a}from"./chunks/framework.DqA2quMh.js";const k=JSON.parse('{"title":"表达式","description":"","frontmatter":{},"headers":[],"relativePath":"example/expression.md","filePath":"example/expression.md"}'),l={name:"example/expression.md"};function d(n,t,o,c,r,h){return i(),s("div",null,[...t[0]||(t[0]=[a(`<h1 id="表达式" tabindex="-1">表达式 <a class="header-anchor" href="#表达式" aria-label="Permalink to &quot;表达式&quot;">​</a></h1><p>在 <code>RustEdition</code> 版本中, OpenEX 采用 <code>pratt</code> 表达式解析器(替换了原有的中转后缀表达式解析器), 并增加了编译期类型推断与校验功能.</p><div class="warning custom-block"><p class="custom-block-title">注意</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3.14</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>以上的组合都是非法的, 在编译期间可以被 OpenEX 检查出来</p></div><h2 id="类型" tabindex="-1">类型 <a class="header-anchor" href="#类型" aria-label="Permalink to &quot;类型&quot;">​</a></h2><p>虽然 OpenEX 本身是动态类型的, 在变量声明时也无需显示指定类型. <br> 但是解释器内部对基元类型有明确的表示.</p><ul><li><code>string</code> 字符串类型, 支持加法运算进行拼接</li><li><code>number</code> 有符号整数类型, 相当于 <code>int64_t</code> <code>i64</code></li><li><code>float</code> 双精浮点类型, 相当于 <code>double</code> <code>f64</code></li><li><code>null</code> 空类型</li><li><code>bool</code> 布尔类型, 只有 <code>true</code> <code>false</code> 两种值</li><li><code>unknown</code> 未知类型.</li></ul><blockquote><p>编译器无法明确推断出一个函数的返回值或变量的类型会采用 <code>unknown</code> 类型进行标记. <br> 此时, 编译器不再对 <code>unknown</code> 类型进行编译期类型检查</p></blockquote><h2 id="算术运算" tabindex="-1">算术运算 <a class="header-anchor" href="#算术运算" aria-label="Permalink to &quot;算术运算&quot;">​</a></h2><blockquote><p>在 <code>number</code> 与 <code>float</code> 类型混合运算中, 最终的产生的计算结果类型为 <code>float</code></p></blockquote><table tabindex="0"><thead><tr><th style="text-align:center;">运算符</th><th style="text-align:left;">类型</th><th style="text-align:left;">运算类型</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:center;"><code>+</code></td><td style="text-align:left;">双目运算符</td><td style="text-align:left;"><code>str</code> <code>number</code> <code>float</code></td><td style="text-align:left;">加法运算</td></tr><tr><td style="text-align:center;"><code>-</code></td><td style="text-align:left;">双目运算符</td><td style="text-align:left;"><code>number</code> <code>float</code></td><td style="text-align:left;">减法运算</td></tr><tr><td style="text-align:center;"><code>*</code></td><td style="text-align:left;">双目运算符</td><td style="text-align:left;"><code>number</code> <code>float</code></td><td style="text-align:left;">乘法运算</td></tr><tr><td style="text-align:center;"><code>/</code></td><td style="text-align:left;">双目运算符</td><td style="text-align:left;"><code>number</code> <code>float</code></td><td style="text-align:left;">除法运算</td></tr><tr><td style="text-align:center;"><code>%</code></td><td style="text-align:left;">双目运算符</td><td style="text-align:left;"><code>number</code> <code>float</code></td><td style="text-align:left;">取余运算</td></tr><tr><td style="text-align:center;"><code>++</code></td><td style="text-align:left;">单目运算符</td><td style="text-align:left;"><code>number</code> <code>float</code></td><td style="text-align:left;">自增运算</td></tr><tr><td style="text-align:center;"><code>--</code></td><td style="text-align:left;">单目运算符</td><td style="text-align:left;"><code>number</code> <code>float</code></td><td style="text-align:left;">自减运算</td></tr><tr><td style="text-align:center;"><code>+</code></td><td style="text-align:left;">单目运算符</td><td style="text-align:left;"><code>number</code> <code>float</code></td><td style="text-align:left;">无效果</td></tr><tr><td style="text-align:center;"><code>-</code></td><td style="text-align:left;">单目运算符</td><td style="text-align:left;"><code>number</code> <code>float</code></td><td style="text-align:left;">取反运算符</td></tr></tbody></table><h2 id="逻辑运算" tabindex="-1">逻辑运算 <a class="header-anchor" href="#逻辑运算" aria-label="Permalink to &quot;逻辑运算&quot;">​</a></h2><blockquote><p>逻辑运算的表达式最终结果一定会被推断为 <code>bool</code> 类型 <br><code>auto</code> 代表任何类型都可以</p></blockquote><table tabindex="0"><thead><tr><th style="text-align:center;">运算符</th><th style="text-align:left;">类型</th><th style="text-align:left;">运算类型</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:center;"><code>==</code></td><td style="text-align:left;">双目运算符</td><td style="text-align:left;"><code>auto</code></td><td style="text-align:left;">比较运算</td></tr><tr><td style="text-align:center;"><code>!=</code></td><td style="text-align:left;">双目运算符</td><td style="text-align:left;"><code>auto</code></td><td style="text-align:left;">不等于运算</td></tr><tr><td style="text-align:center;"><code>&gt;</code></td><td style="text-align:left;">双目运算符</td><td style="text-align:left;"><code>number</code> <code>float</code></td><td style="text-align:left;">大于比较</td></tr><tr><td style="text-align:center;"><code>&lt;</code></td><td style="text-align:left;">双目运算符</td><td style="text-align:left;"><code>number</code> <code>float</code></td><td style="text-align:left;">小于比较</td></tr><tr><td style="text-align:center;"><code>&gt;=</code></td><td style="text-align:left;">双目运算符</td><td style="text-align:left;"><code>number</code> <code>float</code></td><td style="text-align:left;">大于等于</td></tr><tr><td style="text-align:center;"><code>&lt;=</code></td><td style="text-align:left;">双目运算符</td><td style="text-align:left;"><code>number</code> <code>float</code></td><td style="text-align:left;">小于等于</td></tr><tr><td style="text-align:center;"><code>!</code></td><td style="text-align:left;">单目运算符</td><td style="text-align:left;"><code>bool</code></td><td style="text-align:left;">逻辑取反</td></tr></tbody></table><h2 id="警告" tabindex="-1">警告 <a class="header-anchor" href="#警告" aria-label="Permalink to &quot;警告&quot;">​</a></h2><p><code>RustEdition</code> 新增加的编译期警告功能, 会对一些无作用的表达式发出警告信息.</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">func_1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>以上都是无作用表达式, 编译器会对此类表达式发出警告.</p><blockquote><p>可以通过 <code>--allow=unused-expression</code> 命令行参数关闭该警告</p></blockquote><h2 id="优化" tabindex="-1">优化 <a class="header-anchor" href="#优化" aria-label="Permalink to &quot;优化&quot;">​</a></h2><p><code>RustEdition</code> 版本支持了更加强大的常量折叠优化, 会对常量表达式在编译期进行求值.</p><div class="vp-code-group vp-adaptive-theme"><div class="tabs"><input type="radio" name="group-WoV87" id="tab-gOgjwbV" checked><label data-title="source" for="tab-gOgjwbV">source</label><input type="radio" name="group-WoV87" id="tab-OKWnP7_"><label data-title="optimizer" for="tab-OKWnP7_">optimizer</label></div><div class="blocks"><div class="language-js vp-adaptive-theme active line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></div></div><p>对于某些无法求值的表达式, 如类型未知, 值未知的表达式会递交给运行时计算.</p>`,22)])])}const g=e(l,[["render",d]]);export{k as __pageData,g as default};
